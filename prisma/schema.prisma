generator client {
  provider   = "prisma-client"
  output = "../src/db/generated"
}

datasource db {
  provider = "postgresql"
  url = env("DIRECT_URL")
}

enum OrderStatus{
  PENDING
  CONFIRMED
  DELIVERED
  CANCELLED
}

enum CategoryType{
  INGREDIENTS
  SUPPLY
  EQUIPMENT
}

//FUTURE: enums OrderChannel to diff btw internal orders (bakery orders) and external orders (customers orders)
// and DeliveryType to diff btw delivery by bakery or from our delivery service
//FUTURE: enum OrderType to diff btw normal orders and subscriptions
//FUTURE: enum OrderPaymentMethod to diff btw cash, card, etc.

//FUTURE: enum UserRole to difference between admin, customers, deliveries, etc.
//Not all the users will need bakery, orders, etc.

model User {
  id          String    @id @default(uuid()) @map("_id")
  name        String
  lastName    String
  email       String    @unique
  password    String
  role        String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  orders      Order[]

  //If the user is a bakery owner
  ownedBakery Bakery?  @relation("BakeryOwner")

  //If the user is an employee of a bakery
  employeeAtId String?
  employeeAt   Bakery? @relation("BakeryEmployees", fields: [employeeAtId], references: [id])

  @@index([name], name: "user_name_index")
  @@index([createdAt], name: "index_user_createdAt")
}

//FUTURE: model Customer to separate management of bakery owners from consumers customers

model Bakery {
  id          String    @id @default(uuid()) @map("_id")
  name        String
  address     String
  //Separate the address in street, city, and country to enhance the localization experience.
  //Owner relation
  owner       User      @relation("BakeryOwner", fields: [ownerId], references: [id])
  ownerId     String    @unique  // Bakery owner (User)
  //Employees relation
  employees   User[]    @relation("BakeryEmployees")
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  orders      Order[]
  
  // Bakery-specific models (these can link to your other models like ingredients, supplies, recipes)
  ingredients Ingredient[]  // Ingredients for the bakery
  supplies    Supply[]      // Supplies for the bakery
  recipes     Recipe[]      // Recipes for the bakery
  equipments  Equipment[]
  categories  Category[]
  suppliers   Supplier[]
  invitations Invitation[]
}



model Recipe {
  id          String    @id @default(uuid()) @map("_id")
  name        String
  description String
  profitMargin Float
  cost        Float
  suggestedPrice Float
  recipeIngredients RecipeIngredient[]
  steps       Step[]
  category    String
  image       String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
  bakeryId    String    
  bakery      Bakery     @relation(fields: [bakeryId], references: [id])

  OrderItem OrderItem[]

  @@index([name], name: "name_index")
}

//FUTURE: model Product to represent finished products that can be sold, which can be linked to recipes

// Modelo para Ingredientes
model Ingredient {
  id             String          @id @default(uuid()) @map("_id")
  name           String
  pricePerUnit   Float
  unit           String
  totalUnit      Int?
  categoryId     String          
  category       Category @relation(fields: [categoryId], references: [id])
  supplierId     String?          
  supplier       Supplier? @relation(fields: [supplierId], references: [id])
  expirationDate DateTime?
  stockQuantity  Int?
  reorderLevel   Int?
  quantityUsed   Int?
  deletedAt      DateTime?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  recipeIngredients RecipeIngredient[]
  bakeryId         String          
  bakery         Bakery @relation(fields: [bakeryId], references: [id])

  @@index([name], name: "ingredient_name_index")
  @@index([categoryId], name: "index_ingredient_categoryId")
}

// Modelo para el catalogo de ingredientes básico

model IngredientCatalog {
  id            String        @id @default(uuid()) @map("_id")
  name          String
  pricePerUnit  Float?
  unit          String
  categoryId    String         
  category      Category       @relation(fields: [categoryId], references: [id])
}


// Modelo para Suministros
model Supply {
  id             String          @id @default(uuid()) @map("_id")
  name           String
  pricePerUnit   Float
  unit           String
  totalUnit      Int?
  categoryId     String          
  category       Category @relation(fields: [categoryId], references: [id])
  supplierId     String? 
  supplier       Supplier? @relation(fields: [supplierId], references: [id])
  expirationDate DateTime?
  deletedAt      DateTime?
  stockQuantity  Int?
  reorderLevel   Int?
  bakeryId       String          
  bakery         Bakery @relation(fields: [bakeryId], references: [id])
}

// Modelo para Equipamiento
model Equipment {
  id             String          @id @default(uuid()) @map("_id")
  name           String
  pricePerUnit   Float
  unit           String
  totalUnit      Int?
  categoryId     String          
  category       Category @relation(fields: [categoryId], references: [id])
  supplierId     String?          
  supplier       Supplier? @relation(fields: [supplierId], references: [id])
  expirationDate DateTime?
  deletedAt      DateTime?
  stockQuantity  Int?
  reorderLevel   Int?
  bakeryId       String          
  bakery         Bakery @relation(fields: [bakeryId], references: [id])
}

model Category{
  id          String    @id @default(uuid()) @map("_id")
  name        String
  description String?
  type        CategoryType    ///Values 'ingredients' | 'supply' | 'equipment'
  //relacion con usuario opcional
  bakeryId    String?    ///si es null es una categoria global
  bakery      Bakery?     @relation(fields: [bakeryId], references: [id])
  
  ingredients Ingredient[]
  supplies    Supply[]
  equipments  Equipment[]
  commonIngredients IngredientCatalog[]

  @@index([name], name: "category_name_index")
  @@unique([name, bakeryId], name: "unique_category_per_bakery")
}

//FUTURE: order property userId will change to optional 
// to allow order from users not related to a bakery, also user property will be optional
model Order {
  id          String    @id @default(uuid()) @map("_id")
  items       OrderItem[]
  owner       String
  orderNumber String
  orderDate   DateTime @default(now())
  deliveryDate DateTime
  status      OrderStatus @default(PENDING)
  total       Float
  deletedAt   DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  //relacion con usuario
  userId      String    
  user        User @relation(fields: [userId], references: [id])
  bakeryId    String    
  bakery      Bakery    @relation(fields: [bakeryId], references: [id])

  @@index([owner], name: "index_order_owner")
  @@index([orderDate], name: "index_order_orderDate")
}

//add tracking status to Order, FUTURE: enum OrderTrackingStatus to track order status
//FUTURE: create DeliveryPerson model to track delivery persons
//add tipAmount to Order model


model OrderItem {
  id          String    @id @default(uuid()) @map("_id")
  orderId     String    
  order       Order    @relation(fields: [orderId], references: [id])
  recipeId    String    
  recipe      Recipe @relation(fields: [recipeId], references: [id])
  quantity    Int
  price       Float
  deletedAt   DateTime?
  
  @@index([orderId], name: "index_orderItem_orderId")
}

model Supplier{
  id          String    @id @default(uuid()) @map("_id")
  name        String
  phoneNumber String?
  ingredients Ingredient[]
  supplies    Supply[]
  equipments  Equipment[]
  //relacion con usuario
  //a diferencia del modelo category, los proveedores siempre estaran relacionados
  //a una panaderia, no pueden ser globales
  bakeryId    String    
  bakery      Bakery @relation(fields: [bakeryId], references: [id])

  @@unique([name, bakeryId], name: "unique_supplier_per_bakery")
}

// Modelo intermedio para la relación many-to-many entre Recipe e Ingredient
model RecipeIngredient {
  recipeId     String     @id @default(uuid()) @map("_id")
  quantity     Float
  unit         String
  ingredientId String
  recipe       Recipe     @relation(fields: [recipeId], references: [id])
  ingredient   Ingredient @relation(fields: [ingredientId], references: [id])
}

// Modelo para los pasos de una receta
model Step {
  id        String   @id @default(uuid())
  recipeId  String
  recipe    Recipe   @relation(fields: [recipeId], references: [id])
  order     Int
  text      String
}

model Invitation{
  id          String    @id @default(uuid()) @map("_id")
  email       String
  name        String
  token       String    @unique
  role        String
  used        Boolean   @default(false)
  bakeryId    String    
  bakery      Bakery @relation(fields: [bakeryId], references: [id])
  createdAt   DateTime  @default(now())
  expiresAt   DateTime

  @@unique([email, bakeryId], name: "unique_invitation_per_bakery")
}